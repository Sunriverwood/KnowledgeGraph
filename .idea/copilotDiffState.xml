<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/merge_json.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/merge_json.py" />
              <option name="originalContent" value="import os&#10;import json&#10;&#10;&#10;def flatten_properties(obj, parent_key='', sep='.'):&#10;    &quot;&quot;&quot;&#10;    递归地将一个可能包含嵌套字典的字典扁平化。&#10;    &quot;&quot;&quot;&#10;    items = []&#10;    for k, v in obj.items():&#10;        new_key = parent_key + sep + k if parent_key else k&#10;        if isinstance(v, dict):&#10;            items.extend(flatten_properties(v, new_key, sep=sep).items())&#10;        else:&#10;            items.append((new_key, v))&#10;    return dict(items)&#10;&#10;&#10;def merge_and_flatten_knowledge_graph_json(source_directory, output_filename):&#10;    &quot;&quot;&quot;&#10;    遍历指定目录下的所有 JSON 文件，将它们的 'nodes' 和 'relationships'&#10;    合并并扁平化到一个统一的 JSON 文件中。&#10;&#10;    Args:&#10;        source_directory (str): 包含源 JSON 文件的文件夹路径。&#10;        output_filename (str): 合并后输出的 JSON 文件名。&#10;    &quot;&quot;&quot;&#10;    merged_nodes = []&#10;    merged_relationships = []&#10;    processed_files_count = 0&#10;&#10;    print(f&quot;开始扫描目录: '{source_directory}'...&quot;)&#10;&#10;    for filename in os.listdir(source_directory):&#10;        if filename.endswith('.json'):&#10;            file_path = os.path.join(source_directory, filename)&#10;&#10;            try:&#10;                with open(file_path, 'r', encoding='utf-8') as f:&#10;                    data = json.load(f)&#10;&#10;                    if 'nodes' in data and isinstance(data['nodes'], list):&#10;                        for node in data['nodes']:&#10;                            if 'properties' in node and isinstance(node['properties'], dict):&#10;                                node['properties'] = flatten_properties(node['properties'])&#10;                        merged_nodes.extend(data['nodes'])&#10;&#10;                    if 'relationships' in data and isinstance(data['relationships'], list):&#10;                        for rel in data['relationships']:&#10;                            # 校验 type 字段，只有存在且不为 None 的关系才处理&#10;                            if not rel.get('type'):&#10;                                continue&#10;                            if 'properties' in rel and isinstance(rel['properties'], dict):&#10;                                rel['properties'] = flatten_properties(rel['properties'])&#10;                            merged_relationships.append(rel)&#10;&#10;                    print(f&quot;  [+] 成功处理文件: {filename}&quot;)&#10;                    processed_files_count += 1&#10;&#10;            except json.JSONDecodeError:&#10;                print(f&quot;  [!] 警告: 文件 '{filename}' 不是有效的 JSON 格式，已跳过。&quot;)&#10;            except Exception as e:&#10;                print(f&quot;  [!] 错误: 处理文件 '{filename}' 时发生错误: {e}&quot;)&#10;&#10;    if processed_files_count == 0:&#10;        print(&quot;未找到任何 JSON 文件，程序退出。&quot;)&#10;        return&#10;&#10;    merged_graph = {&#10;        &quot;nodes&quot;: merged_nodes,&#10;        &quot;relationships&quot;: merged_relationships&#10;    }&#10;&#10;    try:&#10;        with open(output_filename, 'w', encoding='utf-8') as f:&#10;            json.dump(merged_graph, f, ensure_ascii=False, indent=2)&#10;&#10;        print(&quot;\n合并并扁平化完成！&quot;)&#10;        print(f&quot;  - 总共处理了 {processed_files_count} 个 JSON 文件。&quot;)&#10;        print(f&quot;  - 合并后的节点总数: {len(merged_nodes)}&quot;)&#10;        print(f&quot;  - 合并后的关系总数: {len(merged_relationships)}&quot;)&#10;        print(f&quot;  - 结果已保存至: '{output_filename}'&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;\n[!] 错误: 无法写入输出文件 '{output_filename}': {e}&quot;)&#10;&#10;&#10;# --- 使用示例 ---&#10;if __name__ == &quot;__main__&quot;:&#10;    SOURCE_FOLDER = './json/'  # 使用 './' 代表当前脚本所在的文件夹&#10;    OUTPUT_FILE = 'merged_knowledge_graph.json'&#10;&#10;    merge_and_flatten_knowledge_graph_json(SOURCE_FOLDER, OUTPUT_FILE)" />
              <option name="updatedContent" value="import os&#10;import json&#10;&#10;&#10;def flatten_properties(obj, parent_key='', sep='.'):&#10;    &quot;&quot;&quot;&#10;    递归地将一个可能包含嵌套字典的字典扁平化。&#10;    &quot;&quot;&quot;&#10;    items = []&#10;    for k, v in obj.items():&#10;        new_key = parent_key + sep + k if parent_key else k&#10;        if isinstance(v, dict):&#10;            items.extend(flatten_properties(v, new_key, sep=sep).items())&#10;        else:&#10;            items.append((new_key, v))&#10;    return dict(items)&#10;&#10;&#10;def merge_and_flatten_knowledge_graph_json(source_directory, output_filename):&#10;    &quot;&quot;&quot;&#10;    遍历指定目录下的所有 JSON 文件，将它们的 'nodes' 和 'relationships'&#10;    合并并扁平化到一个统一的 JSON 文件中。&#10;&#10;    Args:&#10;        source_directory (str): 包含源 JSON 文件的文件夹路径。&#10;        output_filename (str): 合并后输出的 JSON 文件名。&#10;    &quot;&quot;&quot;&#10;    merged_nodes = []&#10;    merged_relationships = []&#10;    processed_files_count = 0&#10;&#10;    print(f&quot;开始扫描目录: '{source_directory}'...&quot;)&#10;&#10;    for filename in os.listdir(source_directory):&#10;        if filename.endswith('.json'):&#10;            file_path = os.path.join(source_directory, filename)&#10;&#10;            try:&#10;                with open(file_path, 'r', encoding='utf-8') as f:&#10;                    data = json.load(f)&#10;&#10;                    if 'nodes' in data and isinstance(data['nodes'], list):&#10;                        for node in data['nodes']:&#10;                            if 'properties' in node and isinstance(node['properties'], dict):&#10;                                node['properties'] = flatten_properties(node['properties'])&#10;                        merged_nodes.extend(data['nodes'])&#10;&#10;                    if 'relationships' in data and isinstance(data['relationships'], list):&#10;                        for rel in data['relationships']:&#10;                            # 校验 type 字段，只有存在且不为 None 的关系才处理&#10;                            if not rel.get('type'):&#10;                                continue&#10;                            if 'properties' in rel and isinstance(rel['properties'], dict):&#10;                                rel['properties'] = flatten_properties(rel['properties'])&#10;                            merged_relationships.append(rel)&#10;&#10;                    print(f&quot;  [+] 成功处理文件: {filename}&quot;)&#10;                    processed_files_count += 1&#10;&#10;            except json.JSONDecodeError:&#10;                print(f&quot;  [!] 警告: 文件 '{filename}' 不是有效的 JSON 格式，已跳过。&quot;)&#10;            except Exception as e:&#10;                print(f&quot;  [!] 错误: 处理文件 '{filename}' 时发生错误: {e}&quot;)&#10;&#10;    if processed_files_count == 0:&#10;        print(&quot;未找到任何 JSON 文件，程序退出。&quot;)&#10;        return&#10;&#10;    merged_graph = {&#10;        &quot;nodes&quot;: merged_nodes,&#10;        &quot;relationships&quot;: merged_relationships&#10;    }&#10;&#10;    try:&#10;        with open(output_filename, 'w', encoding='utf-8') as f:&#10;            json.dump(merged_graph, f, ensure_ascii=False, indent=2)&#10;&#10;        print(&quot;\n合并并扁平化完成！&quot;)&#10;        print(f&quot;  - 总共处理了 {processed_files_count} 个 JSON 文件。&quot;)&#10;        print(f&quot;  - 合并后的节点总数: {len(merged_nodes)}&quot;)&#10;        print(f&quot;  - 合并后的关系总数: {len(merged_relationships)}&quot;)&#10;        print(f&quot;  - 结果已保存至: '{output_filename}'&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;\n[!] 错误: 无法写入输出文件 '{output_filename}': {e}&quot;)&#10;&#10;&#10;# --- 使用示例 ---&#10;if __name__ == &quot;__main__&quot;:&#10;    SOURCE_FOLDER = './json/'  # 使用 './' 代表当前脚本所在的文件夹&#10;    OUTPUT_FILE = 'merged_knowledge_graph.json'&#10;&#10;    merge_and_flatten_knowledge_graph_json(SOURCE_FOLDER, OUTPUT_FILE)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>